


Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。
    如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序.

happens-before原则（先行发生原则）:
    1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
    2.锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
    3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
    4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
    5.线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
    6.线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
    7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
    8.对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

volatile（保证了可见性）修饰:
    第一：使用volatile关键字会强制将修改的值立即写入主存(物理内存)；
    第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
    第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。


volatile是否具备原子性：
    自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入内存。
    假如自增操作的3个子操作分开执行，
        线程1对变量进行自增操作，线程1先读取了变量的原始值，然后线程1被阻塞了。
        线程2对变量进行自增操作，线程2也去读取了变量的原始值，因线程1仅仅是读取了变量的原始值，没有进行修改，所以不会导致线程2的缓存失效，
        此时线程2就自增后存入到了主存中。
        然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存
        那么两个线程分别进行了一次自增操作后，inc只增加了1
    所以不具备原子性
 解决：synchronized、Lock、AtomicInteger


volatile的原理和实现机制
    lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
    1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
    2）它会强制将对缓存的修改操作立即写入主存；
    3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

使用场景
    1）对变量的写操作不依赖于当前值
    2）该变量没有包含在具有其他变量的不变式中